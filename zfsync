#!/bin/bash
# Â©, 2022, Casey Witt
# developed with zfs-0.8.3
# hosted at https://github.com/varasys/zfsync
# script linted with shellcheck (https://www.shellcheck.net/)
# initially meant to be posix sh compatable, but could not work out reliable enough error handling with posix sh

readonly VERSION="0.0.1"

# note that ~/.ssh/authorized_keys file on the backup server must have an entry of the following form:
# restrict,command="zfsync server pool/path" ssh-ed25519 <key> [comment]

# [ ] TODO create udev rule to import pool and perform mirror on usb drive hotplug
# [ ] TODO implement pre/post snap and mirror hooks
# [ ] TODO implement localhost mirroring (without ssh)
# [ ] TODO implement creating dummy datasets on backup server for broken chains (probably not; let the user do this manually??)
# [x] TODO implement pruning (maybe; consider this may be best for seperate script; or may be best for this script to prune on remote also)
# [x] TODO seperate snap and mirror into two seperate systemd services
# [x] TODO add quota option to `zfsync allowreceive`
# [x] TODO update sync logic to check for new latest snapshot after each send
# [x] TODO config zfsync user (as sender and receiver)

set -euo pipefail # fast fail on errors, undefined variables, and pipeline errors


readonly AUTOSNAPPROP="${AUTOSNAPPROP:-"com.sun:auto-snapshot"}" # dataset user property (set false to exclude dataset from snapshoting and backups)
readonly AUTOMIRRORPROP="${AUTOMIRRORPROP:-"${AUTOSNAPPROP}"}"
# readonly AUTOPRUNEPROP="${AUTOPRUNEPROP:-"${AUTOSNAPPROP}"}"
readonly SNAPPREFIX="${SNAPPREFIX:-"zfsync_"}" # prefix for snapshot name
readonly DATECMD="${DATECMD:-"date -u +%F_%H-%M-%S_UTC"}" # command to generate snapshot name timestamp
if [ -z "${BUFFER:-}" ]; then
  if command -v mbuffer >/dev/null; then
    readonly BUFFER="$(command -v mbuffer) -s 128k -q"
  else
    warn 'mbuffer executable not found'
    readonly BUFFER="$(command -v cat)"
  fi
fi

ERR=0 # error counter (incremented when error function is called)
trap 'exit $ERR' EXIT # note that the connect function redefines this if it is called

log() {
  local -r MSG="$1"; shift
  # shellcheck disable=2059 # allow variable in printf format string
  printf "\e[1m${MSG}\e[0m\n" "$@" >&2
}

debug() {
  if [ "${DEBUG:-}" = true ]; then # this will be set when first command line argument is "-d"
    local -r MSG="$1"; shift
    # shellcheck disable=2059 # allow variable in printf format string
    printf "\e[1m\e[4;36m${MSG}\e[0m\n" "$@" >&2
  fi
}

warn() {
  local -r MSG="$1"; shift
  # shellcheck disable=2059 # allow variable in printf format string
  printf "\e[1m\e[35m${MSG}\e[0m\n" "$@" >&2
}

error() {
  local -r MSG="$1"; shift
  # shellcheck disable=2059 # allow variable in printf format string
  printf "\e[1m\e[31m${MSG}\e[0m\n" "$@" >&2
  ((ERR++))
}

fatal() {
  local -r MSG="$1"; shift
  # shellcheck disable=2059 # allow variable in printf format string
  printf "\e[1m\e[31m${MSG}\e[0m\n" "$@" >&2
  ((ERR++))
  exit $ERR
}

readonly ZFS="$(command -v zfs)"
[ -n "${ZFS}" ] || fatal 'fatal error: zfs command not found'

snapshot() {
  local -r SNAPSHOT="${SNAPPREFIX}$(${DATECMD})"
  #shellcheck disable=2207 # do not quote process substitution
  local -ar SNAPSHOTS=( $($ZFS list -Ho "name,${AUTOSNAPPROP}" -s name "$@" \
    | awk -v suf="@${SNAPSHOT}" '{ if ($2 != "false") print $1 suf }' \
    | uniq) )
  if [ ${#SNAPSHOTS[@]} -gt 0 ]; then
    $ZFS snapshot "${SNAPSHOTS[@]}"
    local SNAP
    for SNAP in "${SNAPSHOTS[@]}"; do
      $ZFS bookmark "${SNAP}" "${SNAP//\@/\#}"
    done
    $ZFS list -t snapshot,bookmark "${SNAPSHOTS[@]}" "${SNAPSHOTS[@]//\@/\#}"
  fi
}

connect() {
  if [ -z "${RPC:-}" ]; then # don't reconnect if $RPC is already defined
    local -r HOST="$1"
    local -r SSH="$(command -v ssh)"
    [ -n "${SSH}" ] || fatal 'fatal error: ssh command not found'
    local -r SOCKET="${HOME}/.ssh/zfsync_${HOST}_$(date +%s%N)"
    # log 'connecting to ssh host: %s ...' "${HOST}"
    ${SSH} -fMN -S "${SOCKET}" "${HOST}"
    # shellcheck disable=2064 # expand HOST and SOCKET at definition time
    trap "
      # log 'disconnecting from ssh host: %s ...' '${HOST}'
      ${SSH} -S '${SOCKET}' -O exit '${HOST}' 2>/dev/null
      exit \$ERR
    " EXIT
    readonly RPC=$(printf '%s -o ControlMaster=no -S %s %s' "${SSH}" "${SOCKET}" "${HOST}")
    export RPC # need to export so function subshells have access
  fi
}

create_remote() {
  local -r SOURCE="$1"
  local -r FIRST=$($ZFS list -t snap -Ho name -s creation "${SOURCE}" \
    | head -n 1)
  $ZFS send -DLcew "${FIRST}" | $BUFFER | $RPC receive -s "${SOURCE}"
}

resume_remote() {
  local -r SOURCE="$1"
  local -r TOKEN="$2"
  $ZFS send -e -t "${TOKEN}" | $BUFFER | $RPC receive -s "${SOURCE}"
}

update_remote() {
  local -r SOURCE="$1"
  local -r REMOTEGUID="$2"
  local STARTSNAP
  STARTSNAP="$($ZFS list -Ho name,guid -t snapshot -s creation "${SOURCE}" \
    | awk "\$2 == ${REMOTEGUID} { print \$1 }")"
  # if STARTSNAP is not found then search bookmarks
  [ -n "${STARTSNAP}" ] || STARTSNAP="$($ZFS list -Ho name,guid -t bookmark -s creation "${SOURCE}" \
    | awk "\$2 == ${REMOTEGUID} { print \$1 }")"
  [ -n "${STARTSNAP}" ] || fatal "can't find snapshot/bookmark for guid=%s" "${REMOTEGUID}"
  local -r FINISHSNAP="$($ZFS list -t snap -Ho name -S creation "${SOURCE}" | head -n 1)"
  $ZFS send -DLcew -I "${STARTSNAP}" "${FINISHSNAP}" | $BUFFER | $RPC receive -s "${SOURCE}"
}

mirror() {
  # shellcheck disable=2207 # don't quote process substitution
  local -ar DATASETS=( $($ZFS list -Ho "name,${AUTOMIRRORPROP}" -s name "$@" \
    | awk '{ if ($2 != "false") print $1 }' | uniq) )
  local DATASET
  for DATASET in "${DATASETS[@]}"; do
    ( # operate in a subshell so fatel error will continue loop instead of exiting script
      log '\nmirroring %s ...' "${DATASET}"
      local STATUS
      STATUS="$($RPC status "${DATASET}")"
      until
        debug 'remote STATUS: %s' "$STATUS"
        local GUID
        GUID="$($ZFS list -t snap -Ho guid -S creation "${DATASET}" | head -n 1)" || fatal 'error querying guid for %s' "${DATASET}"
        debug 'local GUID: %s' "$GUID"
        [ -n "${GUID}" ] || fatal "error mirroring %s - no existing snapshots" "${DATASET}"
        [ "${GUID}" = "${STATUS#guid=}" ] && debug 'complete: %s synced to GUID=%s' "${DATASET}" "${GUID}"
      do
        case "${STATUS}" in
          receive_resume_token=*)
            log 'resuming: %s ...' "${DATASET}"
            STATUS="$(resume_remote "${DATASET}" "${STATUS#receive_resume_token=}")" || fatal 'error resuming %s' "${DATASET}"
            ;;
          guid=*)
            log 'updating %s (%s => %s) ...' "${DATASET}" "${STATUS}" "${GUID}"
            STATUS="$(update_remote "${DATASET}" "${STATUS#guid=}")" || fatal 'error updating %s' "${DATASET}"
            ;;
          *)
            log 'creating: %s ...' "${DATASET}"
            STATUS="$(create_remote "${DATASET}")" || fatal 'error creating remote %s' "${DATASET}"
            ;;
        esac
      done
    ) || ERR=$?
  done
}

server() { # run from authorized_keys file on the backup server (ie. command="zfsync receive zpool/backups")
  local -a ARGS=( )
  local -r TARGET="$1" # the dataset path prefix including pool name (ie. zpool/backups)
  prepare() { # function to add local dataset prefix to datasets
    local -r OPTSTRING="$1" # getopts optstring of allowable flags (ie. ":rd:Ho:t:s:S:")
    shift
    ARGS=( "$@" )
    local OPTIND=1
    local OPT
    # the main reason to run getopts is to determine when the options end
    # in order to prefix all of the datasets with the TARGET prefix
    while getopts "${OPTSTRING}" OPT "${ARGS[@]}"; do
      case "${OPT}" in
        \?) fatal 'Invalid option: -%s' "${OPTARG}";;
        :) fatal 'Option -%s requires an argument' "${OPTARG}";;
      esac
    done
    # now that all options have been parsed, everything else must be prefixed
    if [ ${OPTIND} -gt $# ]; then
      ARGS+=( "${TARGET}" ) # no dataset was provided, so add TARGET as the dataset
    else # add TARGET prefix to everything after the options
      while [ ${OPTIND} -le $# ]; do
        ARGS[OPTIND-1]="${TARGET}/${ARGS[OPTIND-1]}"
        ((OPTIND++))
      done
    fi
  }
  # shellcheck disable=2086 # use word splitting below
  set -- ${SSH_ORIGINAL_COMMAND}
  local -r SUBCMD="$1"; shift
  case "${SUBCMD}" in
    'status')
      local -r SOURCE="$1"
      local TOKEN
      TOKEN="$($ZFS list -Ho receive_resume_token "${TARGET}/${SOURCE}" 2>/dev/null)"
      if [ "${TOKEN}" = "-" ]; then # dataset exists so check for guid
        local -r GUID="$($ZFS list -t snapshot -Ho guid -S creation "${TARGET}/${SOURCE}" | head -n 1)"
        if [ -n "${GUID}" ]; then
          TOKEN="guid=${GUID}" # respond with the guid
        else
          TOKEN="detached" # the dataset exists, but has no snapshots
        fi
      elif [ -n "${TOKEN}" ]; then # there is a resume token (which is not '-') so use it
        TOKEN="receive_resume_token=${TOKEN}"
      else
        TOKEN='missing'
      fi
      printf '%s' "${TOKEN}"
      ;;
    'receive')
      prepare ":Penvt:Fhsuo:x:dA" "$@"
      ${BUFFER} | $ZFS receive "${ARGS[@]}"
      SSH_ORIGINAL_COMMAND="status ${*: -1}" server "${TARGET}";;
    'list')
      prepare ":rd:Hpo:t:s:S:" "$@"
      $ZFS list "${ARGS[@]}";;
    'send')
      prepare ":DLPRbcehnpvwi:I:" "$@"
      $ZFS send "${ARGS[@]}";;
    'destroy')
      prepare ":Rdfnprv" "$@"
      $ZFS destroy "${ARGS[@]}";;
    'prune')
      prepare ":frd:" "$@"
      prune "${ARGS[@]}";;
    *)
      #shellcheck disable=2016 # don't expand %s below
      fatal 'fatal error: unknown command `%s`\n' "$SSH_ORIGINAL_COMMAND"
      ;;
  esac
}

configuser() {
  local -r USER="${1:-"zfsync"}"
  local -r HOMEDIR="${2:-"/usr/local/share/zfsync"}"
  if id "${USER}" >/dev/null 2>&1; then
    warn 'user %s already exists' "${USER}"
  else
    useradd --home-dir "${HOMEDIR}" --no-create-home \
      --shell "$(command -v bash || command -v sh)" --system "${USER}"
    log 'user %s created' "${USER}"
  fi
  if [ -d "${HOMEDIR}" ]; then
    warn 'home directory %s already exists' "${HOMEDIR}"
  else
    mkdir -p "${HOMEDIR}"
    chown "${USER}:${USER}" "${HOMEDIR}"
    log 'home directory %s created' "${HOMEDIR}"
  fi
  [ -L "${HOMEDIR}/ssh" ] || ln -s ".ssh" "${HOMEDIR}/ssh"
  if [ -f "${HOMEDIR}/.ssh/id_ed25519" ]; then
    warn 'ssh key %s already exists' "${HOMEDIR}/.ssh/id_ed25519"
  else
    su -c "mkdir -p -m 700 '${HOMEDIR}/.ssh'" - "${USER}"
    su -c "ssh-keygen -f '${HOMEDIR}/.ssh/id_ed25519' -t ed25519 -N ''" - "${USER}"
    log 'ssh key %s created' "${HOMEDIR}/.ssh/id_ed25519"
  fi
}

restart_as_root() {
  if [ "$(id -u)" -ne 0 ]; then
    warn "restarting as root ..."
    exec sudo -E "$0" "$@"
  fi
}

allowsend() {
  local -r DATASET="${1:?"missing dataset argument"}"
  local -r USER="${2:-"zfsync"}"
  # shellcheck disable=2016 # don't expand command below
  id "${USER}" >/dev/null 2>&1 \
    || fatal 'user %s does not exist - consider running `%s configuser %s`' "${USER}" "$(basename "$0")"
  local -r PERMS="send,snapshot,bookmark,hold,mount"
  log "granting '%s' permissions to '%s' on dataset '%s'" "${PERMS}" "${USER}" "${DATASET}"
  $ZFS allow "${USER}" "${PERMS}" "${DATASET}"
  $ZFS allow "${DATASET}"
  # shellcheck disable=2016 # don't expand command below
  local -r HOMEDIR="$(su -c 'echo "$HOME"' - "${USER}")"
  if [ -f "${HOMEDIR}/.ssh/id_ed25519.pub" ]; then
    # shellcheck disable=2016 # don't execute command below
    warn 'use the following key with the `zfs allowreceive` command on the remote backup server:'
    cat "${HOMEDIR}/.ssh/id_ed25519.pub"
  else
    warn 'public key not found at: %s' "${HOMEDIR}/.ssh/id_ed25519"
  fi
}

allowreceive() {
  local -r DATASET="${1:?"missing dataset argument"}"
  local -r KEY="${2:?"missing ssh public key argument"}"
  local -r QUOTA="${3:-"none"}"
  local -r USER="${4:-"zfsync"}"
  # shellcheck disable=2016 # don't expand command below
  id "${USER}" >/dev/null 2>&1 \
    || fatal 'user %s does not exist - consider running `%s configuser %s`' "${USER}" "$(basename "$0")"
  local -r PERMS='receive,mount,create,userprop,encryption,canmount,mountpoint,compression,destroy,send,bookmark,keylocation,mount'
  if ! $ZFS list "${DATASET}" >/dev/null 2>&1; then
    warn 'creating dataset %s' "${DATASET}"
    $ZFS create -o mountpoint=none -p "${DATASET}"
  fi
  log "granting '%s' permission to '%s' on dataset '%s'" "${PERMS}" "${USER}" "${DATASET}"
  $ZFS allow "${USER}" "${PERMS}" "${DATASET}"
  $ZFS allow "${DATASET}"
  log "setting quota='%s' on dataset '%s'" "${QUOTA}" "${DATASET}"
  $ZFS set quota="${QUOTA}" "${DATASET}"
  local -r AUTHCMD="restrict,command=\"zfsync server ${DATASET}\" ${KEY}"
  # shellcheck disable=2016 # don't expand $HOME below
  local -r HOMEDIR="$(su -c 'echo "$HOME"' - "${USER}")"
  if grep -q "${AUTHCMD}" "${HOMEDIR}/.ssh/authorized_keys" 2>/dev/null; then
    log 'authorized_keys file already contains the specified key'
  elif grep "${KEY}" "${HOMEDIR}/.ssh/authorized_keys" 2>/dev/null; then
    warn '%s already contains the specified key; but may not be correct' "${HOMEDIR}/.ssh/authorized_keys"
    warn 'manually update with the following:'
    echo "${AUTHCMD}"
  else
    log 'updating %s' "${HOMEDIR}/.ssh/authorized_keys"
    echo "${AUTHCMD}" >> "${HOMEDIR}/.ssh/authorized_keys"
  fi
}

prune() {
  if [ "${1:-}" = '-f' ]; then # actually destroy snapshots
    local -r DESTROY="$ZFS destroy"; shift
  else # just do a dry run
    local -r DESTROY=":"
  fi

  compare() {
    local -r FORMAT="$1"
    local -r CURRENT="$2"
    local -r PREV="$3"
    # shellcheck disable=2086 # don't quote ARGS
    [ "$(date --date="@${CURRENT}" ${FORMAT})" = "$(date --date="@${PREV}" ${FORMAT})" ]
  }

  local -r NOW="$(date --date="${START:-$(date)}" +%s)" # START is used for debugging
  # time durations                # backup frequency buckets
  local -r SECOND=$((1))          # (ie. save hourly snapshots for 7 days)
  local -r MINUTE=$((60*SECOND))  # (ie. save daily snapshots for 4 weeks)
  local -r HOUR=$((60*MINUTE));   local -r FREQUENT=$((4*HOUR))
  local -r DAY=$((24*HOUR));      local -r HOURLY=$((7*DAY))
  local -r WEEK=$((7*DAY));       local -r DAILY=$((4*WEEK))
  local -r QUARTER=$((13*WEEK));  local -r WEEKLY=$((2*QUARTER))
  local -r YEAR=$((4*QUARTER));   local -r MONTHLY=$((6*YEAR))
                                  local -r YEARLY=$((10*YEAR))
  local -A PREV
  while read -r CREATION DATASET SNAPSHOT; do
    local NAME="${DATASET}@${SNAPSHOT}"
    local PRUNE=false
    if [ "${PREV[DATASET]:-}" = "${DATASET}" ]; then
      local AGE=$((NOW-CREATION))
      if [ ${AGE} -lt ${FREQUENT} ]; then # save everything
        : # keep everything
      elif [ ${AGE} -lt ${HOURLY} ]; then # save last in each hour
        compare "+%Y-%m-%d_%H" "${CREATION}" "${PREV[CREATION]}" && PRUNE=true
      elif [ ${AGE} -lt ${DAILY} ]; then # save last in each day
        compare "+%Y-%m-%d" "${CREATION}" "${PREV[CREATION]}" && PRUNE=true
      elif [ ${AGE} -lt ${WEEKLY} ]; then # save last in each week
        compare "+%Y-%U" "${CREATION}" "${PREV[CREATION]}" && PRUNE=true
      elif [ ${AGE} -lt ${MONTHLY} ]; then # save last in each month
        compare "+%Y-%m" "${CREATION}" "${PREV[CREATION]}" && PRUNE=true
      elif [ ${AGE} -lt ${YEARLY} ]; then # save last in each year
        compare "+%Y" "${CREATION}" "${PREV[CREATION]}" && PRUNE=true
      fi # then save everything over 10 years
    fi
    if [ "${PRUNE}" = true ]; then
      warn 'destroying %s' "${NAME}"
      $DESTROY "${NAME}" || ERR=$((ERR+1))
    else
      log 'retaining %s' "${NAME}"
    fi
    PREV=( [CREATION]="$CREATION" [DATASET]="$DATASET" [SNAPSHOT]="$SNAPSHOT" )
  done < <( # need this to be in a subshell so the while loop can increment ERR
    # if [ -t 0 ]; then # stdin is not piped, so run zfs command
    #   $ZFS list -t snapshot -Hpo "${AUTOPRUNEPROP},creation,name" "$@"
    # else # stdin is piped, so pass through input from stdin
    #   cat # but note there is no error handling for bad input
    # fi \
    # | awk -F '\t|@' '$1 == "true" { print $2, $3, $4 }' \
    $ZFS list -t snapshot -Hpo creation,name "$@" \
      | awk -F '\t|@' '{ print $1, $2, $3 }' \
      | sort -k 2,2r -k 1,1nr
  )
}

if [ "${1:-}" = '-d' ]; then
  DEBUG=true
  shift
fi
readonly CMD="${1:-}"
[ $# -gt 0 ] && shift
case "${CMD}" in
  'snap'|'snapshot')
    # help: \nsnap|snapshot: create new snapshot(s)
    # help:   zfsync snapshot [-r|-d depth] <dataset> ...
    snapshot "$@";;
  'mirror')
    # help: \nmirror: mirror snapshot(s) to remote server
    # help:   zfsync mirror <host> [-r|-d depth] <dataset> ...
    HOST="${1:?"missing hostname argument"}"; shift
    connect "${HOST}"
    mirror "$@";;
  'backup')
    # help: \nbackup: run `snap` and then `mirror` in a single command
    # help:   zfsync backup <host> [-r|-d depth] <dataset> ...
    HOST="${1:?"missing hostname argument"}"; shift
    snap "$@"
    connect "${HOST}"
    mirror "$@";;
  'prune')
    # help: \nprune: prune old snapshots
    # help:   zfsync prune [-r|-d depth] [dataset]...
    prune "$@";;
  'rprune')
    # help: \nrprune: prune old snapshots on remote backup server
    # help:   zfsync rprune destination [-r|-d depth] [dataset]...
    HOST="${1:?"missing hostname argument"}"; shift
    connect "${HOST}"
    $RPC prune "$@";;
  'server')
    # help: \nserver: run in server mode on the backup host (from .ssh/authorized_keys file)
    # help:   zfsync server <dataset_root>
    server "$@";;
  'list')
    # help: \nlist: run `zfs list` remotely on backup server (ie. query the backup server from the client)
    # help:   zfsync list <host> [options] <dataset> ...
    HOST="${1:?"missing hostname argument"}"; shift
    connect "${HOST}"
    $RPC list "$@";;
  'destroy')
    # help: \ndestroy: run `zfs destroy` remotely on backup server (ie. destroy dataset on server from the client)
    # help:   zfsync destroy <host> [options] <dataset>
    HOST="${1:?"missing hostname argument"}"; shift
    connect "${HOST}"
    $RPC destroy "$@";;
  'recover')
    # help: \nrecover: run `zfs send` remotely on backup server (ie. to restore a snaphshot from the backup server)
    # help:   zfsync recover <host> [options] <dataset>
    HOST="${1:?"missing hostname argument"}"; shift
    connect "${HOST}"
    $RPC send "$@";;
  'configuser')
    # help: \nconfiguser: create zfsync user, /etc/zfsync directory, and /etc/zfsync/id_ed25519 ssh key
    # help:   zfsync configuser [username] [home_dir]
    restart_as_root configuser "$@"
    configuser "$@";;
  'allowsend')
    # help: \nallowsend: delegate zfs permissions to zfsync user to be able to send dataset (on client)
    # help:   zfsync allowsend <dataset> [username]
    restart_as_root allowsend "$@"
    allowsend "$@";;
  'allowreceive')
    # help: \nallowreceive: delegate zfs permissions to zfsync user to be able to receive into dataset (on server)
    # help:   zfsync allowreceive <dataset> <key> [quota] [username]
    restart_as_root allowreceive "$@"
    allowreceive "$@";;
  'version')
    echo "zfsync-${VERSION}";;
  *)
    [ "${CMD}" = "-?" ] || error "\nfatal error: unknown command%s" "${CMD:+": \`${CMD}\`"}"
    log 'zfsync is a shell script to create and mirror zfs snapshots.\nusage:'
    grep '# help: ' "$0" | grep -v 'grep' | sed 's/ *# help: //g' | sed 's/\\n/\n/g'
    # shellcheck disable=2016 # don't expand command below
    log 'see `man zfsync` for more information'
    ;;
esac
